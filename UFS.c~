#include "UFS.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "disque.h"

// Quelques fonctions qui pourraient vous être utiles
int NumberofDirEntry(int Size) {
	return Size/sizeof(DirEntry);
}

int min(int a, int b) {
	return a<b ? a : b;
}

int max(int a, int b) {
	return a>b ? a : b;
}

/* Cette fonction va extraire le repertoire d'une chemin d'acces complet, et le copier
   dans pDir.  Par exemple, si le chemin fourni pPath="/doc/tmp/a.txt", cette fonction va
   copier dans pDir le string "/doc/tmp" . Si le chemin fourni est pPath="/a.txt", la fonction
   va retourner pDir="/". Si le string fourni est pPath="/", cette fonction va retourner pDir="/".
   Cette fonction est calquée sur dirname, que je ne conseille pas d'utiliser car elle fait appel
   à des variables statiques/modifie le string entrant. Voir plus bas pour un exemple d'utilisation. */
int GetDirFromPath(const char *pPath, char *pDir) {
	strcpy(pDir,pPath);
	int len = strlen(pDir); // length, EXCLUDING null
	int index;

	// On va a reculons, de la fin au debut
	while (pDir[len]!='/') {
		len--;
		if (len <0) {
			// Il n'y avait pas de slash dans le pathname
			return 0;
		}
	}
	if (len==0) {
		// Le fichier se trouve dans le root!
		pDir[0] = '/';
		pDir[1] = 0;
	}
	else {
		// On remplace le slash par une fin de chaine de caractere
		pDir[len] = '\0';
	}
	return 1;
}

/* Cette fonction va extraire le nom de fichier d'une chemin d'acces complet.
   Par exemple, si le chemin fourni pPath="/doc/tmp/a.txt", cette fonction va
   copier dans pFilename le string "a.txt" . La fonction retourne 1 si elle
   a trouvée le nom de fichier avec succes, et 0 autrement. Voir plus bas pour
   un exemple d'utilisation. */
int GetFilenameFromPath(const char *pPath, char *pFilename) {
	// Pour extraire le nom de fichier d'un path complet
	char *pStrippedFilename = strrchr(pPath,'/');
	if (pStrippedFilename!=NULL) {
		++pStrippedFilename; // On avance pour passer le slash
		if ((*pStrippedFilename) != '\0') {
			// On copie le nom de fichier trouve
			strcpy(pFilename, pStrippedFilename);
			return 1;
		}
	}
	return 0;
}


/* Un exemple d'utilisation des deux fonctions ci-dessus :
int bd_create(const char *pFilename) {
	char StringDir[256];
	char StringFilename[256];
	if (GetDirFromPath(pFilename, StringDir)==0) return 0;
	GetFilenameFromPath(pFilename, StringFilename);
	                  ...
*/


/* Cette fonction sert à afficher à l'écran le contenu d'une structure d'i-node */
void printiNode(iNodeEntry iNode) {
	printf("\t\t========= inode %d ===========\n",iNode.iNodeStat.st_ino);
	printf("\t\t  blocks:%d\n",iNode.iNodeStat.st_blocks);
	printf("\t\t  size:%d\n",iNode.iNodeStat.st_size);
	printf("\t\t  mode:0x%x\n",iNode.iNodeStat.st_mode);
	int index = 0;
	for (index =0; index < N_BLOCK_PER_INODE; index++) {
		printf("\t\t      Block[%d]=%d\n",index,iNode.Block[index]);
	}
}


/* ----------------------------------------------------------------------------------------
					            à vous de jouer, maintenant!
   ---------------------------------------------------------------------------------------- */


/* Retourne le numero d'inode du fichier pFileName dans le répertoire associé au numero d'inode parentINodeNum */
int getFileINodeNumFromParent(const char *pFileName, int parentINodeNum) {
	if (strcmp(pFileName, "") == 0) return parentINodeNum;
	char blockData[BLOCK_SIZE];
	// On trouve le numero du block d'i-nodes qui contient le numero d'i-node parent
	int iNodesBlockNum = BASE_BLOCK_INODE + (parentINodeNum / NUM_INODE_PER_BLOCK);
	// Lecture du block d'i-nodes
	ReadBlock(iNodesBlockNum, blockData);
	iNodeEntry *pINodes = (iNodeEntry *) blockData;
	// On trouve la position de l'i-node parent dans le block d'i-nodes
	UINT16 iNodePosition = parentINodeNum % NUM_INODE_PER_BLOCK;
	// On trouve le nombre d'entrées dans le block de l'i-node parent
	UINT16 entryNum = NumberofDirEntry(pINodes[iNodePosition].iNodeStat.st_size);
	// Lecture du block de données associé à l'i-node parent
	ReadBlock(pINodes[iNodePosition].Block[0], blockData);
	DirEntry *pDE = (DirEntry *) blockData;
	// Pour chaque entrée du block (sauf . et ..) on vérifie le nom de fichier
	size_t n;
	for (n = 0; n < entryNum; n++) {
		if (strcmp(pFileName, pDE[n].Filename) == 0) {
			return pDE[n].iNode;	// On a trouvé le numéro d'i-node correspondant au nom de fichier/repertoire
		}
	}
	return -1;	// Le nom de fichier/répertoire n'existe pas
}



/* Fait une récursion sur le path pPath et retourne le numéro d'inode du fichier pFilename */
int getInode(const char *pPath, const char *pFilename, int parentINodeNum) {
	if (parentINodeNum == -1) return -1;

	char pName[FILENAME_SIZE];
	int iCar, iSlash = 0;
	for (iCar = 0; iCar < FILENAME_SIZE; iCar++) {
		if (pPath[iCar] == 0) break;
		else if (pPath[iCar] == '/' && iCar != 0) break;
		else if (pPath[iCar] == '/') iSlash++;
		else {
			pName[(iCar-iSlash)] = pPath[iCar];
		}
	}
	pName[iCar - iSlash] = 0;
	if (strcmp(pFilename, pName) == 0) {
		return getFileINodeNumFromParent(pName, parentINodeNum);
	} else {
		getInode(pPath + strlen(pName) + 1, pFilename, getFileINodeNumFromParent(pName, parentINodeNum));
	}
}

/* Retourne le numero d'inode correspondant au fichier spécifié par le path */
int getFileINodeNumFromPath(const char *pPath) {
	if (strcmp(pPath, "/") == 0) return ROOT_INODE;
	char pName[FILENAME_SIZE];
	if (GetFilenameFromPath(pPath, pName) == 0) pName[0] = 0;
	return getInode(pPath, pName, ROOT_INODE);
}

/* PPPAAAATTTTAAATTTEEEEE*/


int bd_countfreeblocks(void) {
	return 0;
}

int bd_stat(const char *pFilename, gstat *pStat) {
	return -1;
}

int bd_create(const char *pFilename) {
	return -1;
}

int bd_read(const char *pFilename, char *buffer, int offset, int numbytes) {

  ino iNodeNum = getFileINodeNumFromPath(pFilename);
  iNodeEntry iNode;

  if (iNodeNum == -1) return -1;							// Le fichier pFilename est inexistant
  if (getINodeEntry(iNodeNum, &iNode) != 0) return -1;	// Le fichier pFilename est inexistant
  if (iNode.iNodeStat.st_mode & G_IFDIR) return -2; 		// Le fichier pFilename est un répertoire
  if (iNode.iNodeStat.st_size <= offset) return 0; 		// L'offset engendre un overflow
  
  char fileDataBlock[BLOCK_SIZE];
  ReadBlock(iNode.Block[0], fileDataBlock);
  int i = 0, octets = 0;
  for (i = offset; i < iNode.iNodeStat.st_size && i < (offset + numbytes); i++) {
    buffer[octets] = fileDataBlock[i];
    octets++;
  }
  return octets; // retourne le nombre d'octets lus
  return -1;
}

int bd_mkdir(const char *pDirName) {
	return -1;
}

int bd_write(const char *pFilename, const char *buffer, int offset, int numbytes) { 
	return -1;
}

int bd_hardlink(const char *pPathExistant, const char *pPathNouveauLien) {
	return -1;
}

int bd_unlink(const char *pFilename) {
	return -1;
}

int bd_truncate(const char *pFilename, int NewSize) {
	return -1;
}

int bd_rmdir(const char *pFilename) {
	return -1;
}

int bd_rename(const char *pFilename, const char *pDestFilename) {
	return -1;
}

int bd_readdir(const char *pDirLocation, DirEntry **ppListeFichiers) {
	return -1;
}

int bd_symlink(const char *pPathExistant, const char *pPathNouveauLien) {
    return -1;
}

int bd_readlink(const char *pPathLien, char *pBuffer, int sizeBuffer) {
    return -1;
}

